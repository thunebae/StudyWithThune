---
title: "Malware assignment"
author: "thunebae"
date: 2022-07-19T12:00:06+09:00
description: "Some experiment demo with everything that I study in school. Simple, unrealistic but I spend a lot of time on it. "
tags:
- thunebae
- project
series:
- Project
categories:
- Project
libraries:
- Project
image: "/images/project/malware/virus.png"
---

### Framework: pefile python 
### Ex1 -  File Infecting Virus
{{% alert theme="info" %}}**ðŸ“‘ CHALL 1:** Add a new sectiion in pe file or use .reloc section to contain virus (Simple MessageBox). When program start, call virus first and program run normally. {{% /alert %}}

Honestly it's not a virus, it's not contagious. It's just an experiment on inject pe file. Maybe If I has more time to do, I think I can make it...umh contagiousðŸ˜³

{{% alert theme="info" %}}**ðŸ“‘ CHALL 2:** Call hijacking - Like challenge before, but somewhere call instruction in .text section is overwrited by call virus but the program still run normally {{% /alert %}}

I scan all pe file with opcode E8 (opcode of call instruction) start AddressOfEntryPoint (make sure program must run over this instruction), so I pick a first call instruction and overwrite it's `call_offset` by `virus_offset`. After execute MessageBox, we need an instruction to call back a function with `call_offset` overwrited.

**Problem**: need to save registers before execute MessageBox and restore registers to make everything right with an overwrited call after execute MessageBox.

*You can see ource code and more detail by view report assignment at* {{< color "#0000ff" >}}<a href="https://github.com/thunebae/Malware/tree/main/Ex1" title="Github">Github</a>
{{< /color >}}

### Ex1 -  Advanced Virus Techniques
#### 1. Simple XOR-decryptor virus.
Simple MessageBox shellcode encrypted store in new section and decryptor locates in other section. When program start run, `call decryptor` first (AddressOfEntryPoint), decrypt ciphertext and call plaintext shellcode. After all, call old AddressOfEntryPoint that make program run normally.

{{< highlight asm "linenos=table,linenostart=0" >}}
.virus: 01020000
.decryptor: 0101F000
.entry-point: 01012475

lea esi, [0x01020000]
mov ecx, 0x128
xor [esi], ecx
xor [esi], esi
add esi, 4
sub ecx, 4
cmp ecx, 0
jnz 0xFFFFFFED
call 0x00000FDD
{{< / highlight >}}

#### 2. Anti-debugging
{{% alert theme="info" %}}**ðŸ“‘ METHOD 1:** Use BeingDebugged in PEB structure at **fs:[30] + 2** {{% /alert %}}

- BeingDebugged = 0: don't detect debugger, jump decryptor.

- BeingDebugged # 0: detect debugger, don't decrypt ciphertext, (call old AddressOfEntryPoint)

{{< highlight asm "linenos=table,linenostart=0" >}}
mov eax, fs:[0x30]
xor ebx, ebx
mov bl, [eax+2]
test bl, bl
jz 0X0000001E
mov eax, 01012475
call eax
lea esi, [virus]
mov ecx, 0x128
xor [esi], ecx
xor [esi], esi
add esi, 4
sub ecx, 4
cmp ecx, 0
jnz virus
call OldEntryPoint
{{< / highlight >}}

It's maybe fool by edit register store values **fs:[30] + 2** to 0 in debugger ðŸ˜•. So it's just experiment, I can't think more.

{{% alert theme="info" %}}**ðŸ“‘ METHOD 2:** Windows API â€“ IsDebuggerPresent() {{% /alert %}}

I was written a C++ program to compile shellcode to call IsDebuggerPresent() by using offset of this API call in it's library - kernell32.dll, compile to assembly, edit something, export to .exe file and copy shellcode to my target inject PE file. You can see how to do it at {{< color "#0000ff" >}}<a href="https://www.ired.team/offensive-security/code-injection-process-injection/writing-and-compiling-shellcode-in-c" title="Github">Writing and Compiling Shellcode in C</a>
{{< /color >}}
 
- eax = 0: run the following instruction, program run normally.

- eax # 3, decryptor decrypt section .virus, call MessageBox and call old AddressOfEntryPoint.

{{< highlight asm "linenos=table,linenostart=0" >}}
call IsDebuggerPresent()
cmp eax, 0x3
jnz 0x7
mov eax, OldEntryPoint
call eax
lea esi, [virus]
mov ecx, 0x128
xor [esi], ecx
xor [esi], esi
add esi, 4
sub ecx, 4
cmp ecx, 0
jnz virus
call OldEntryPoint
{{< / highlight >}}

#### 3. Anti-VM
{{% alert theme="info" %}}**ðŸ“‘ METHOD 1:** CPUID instruction {{% /alert %}}

*Easy method to implement but also easy to fool it*

CPUID instruction is the command to check the processor information. With input eax=1, if the 31st bit of the ecx output is 1, the application is in a virtual machine environment.

*How to fool this method?* One can configure in the .vmx file to change the ecx output if input eax=1 in the VMWare virtual machine. So you can bypass this check.

{{< highlight asm "linenos=table,linenostart=0" >}}
xor    eax, eax
inc    eax
cpuid
bt     ecx, 0x1f
jb     0x23
lea esi, [virus]
mov ecx, 0x128
xor [esi], ecx
xor [esi], esi
add esi, 4
sub ecx, 4
cmp ecx, 0
jnz virus
call 0x00000FD2
mov eax, OldEntryPoint
call eax
{{< / highlight >}}

{{% alert theme="info" %}}**ðŸ“‘ METHOD 2:** IN instruction {{% /alert %}}

*When I do this method, I think I will give up because fcking SEH is not working but luckily, it works, but only for calc.exe :<<*

IN tutorial is use a read a port, at here port to read is port 0x5658 - â€˜VXâ€™. It requires SEH to handle exception because if VMWare not running, port isn't openning, so nothing can't be read and a execute_exception_handler occurs. So we need something like "try...except" and SEH is a structure management it.

{{< img src="/images/project/malware/in.png" title="HÃ¬nh 1" caption="IN instruction" alt="IN instruction" >}}
*You can see ource code and more detail by view report assignment at* {{< color "#0000ff" >}}<a href="https://github.com/thunebae/Malware/tree/main/Ex2" title="Github">Github</a>
{{< /color >}}